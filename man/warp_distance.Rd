% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distance.R
\name{warp_distance}
\alias{warp_distance}
\title{Compute distances from a date time origin}
\usage{
warp_distance(x, by = "year", every = 1L, origin = NULL)
}
\arguments{
\item{x}{\verb{[Date / POSIXct / POSIXlt]}

The vector to compute time distances for.}

\item{by}{\verb{[character(1)]}

A string defining the period to group by. Valid inputs are:
\itemize{
\item \code{"year"}
\item \code{"quarter"}
\item \code{"month"}
\item \code{"week"}
\item \code{"day"}
\item \code{"hour"}
\item \code{"minute"}
\item \code{"second"}
}}

\item{every}{\verb{[positive integer(1)]}

The number of \code{by} periods to lump together when constructing the groups.
For example, with the default \code{origin} and \code{by = "year"}, \code{every = 2}
would put the years \code{1970} and \code{1971} in the same group.}

\item{origin}{\verb{[Date(1) / POSIXct(1) / POSIXlt(1)]}

The reference value for the distances to be computed from. This is
particularly important when \code{every > 1} and you need to define when the
"first" event was to start counting from.}
}
\value{
An integer vector containing the distances, unless \code{by = "second"}, in which
case a double vector is returned to avoid integer overflow.
}
\description{
\code{warp_distance()} is a low level engine for computing date time distances.

It returns the distance from \code{x} to the \code{origin} in units
defined by the period specified with \code{by}. For example, \code{by = "year"} would
return the number of years from the \code{origin}, which is the Unix epoch of
\verb{1970-01-01 00:00:00 UTC} by default.
}
\details{
The return value of \code{warp_distance()} is suitable for use as a grouping
column in, for example, a \code{dplyr::mutate()}. This is especially useful for
grouping by a multitude of a particular period, such as "every 5 months"
starting from your particular \code{origin} value. If you want "cleaner" grouping
values, you might consider running \code{vctrs::vec_group_id()} on the result from
\code{warp_distance()}.

When the time zone of \code{x} differs from the time zone of \code{origin}, a warning
is issued, and \code{x} is coerced to the time zone of \code{origin} without changing
the number of seconds of \code{x} from the epoch. In other words, the time zone
of \code{x} is directly changed to the time zone of \code{origin} without changing the
underlying numeric representation. \strong{It is highly advised to specify your own
\code{origin} value with the same time zone as \code{x}.}

If a \code{Date} is used for \code{x}, its time zone is assumed to be \code{"UTC"}.

The information in the provided \code{origin} is truncated by the \code{by} period
specified. This means that if you specify \code{by = "month"},
\code{every = 2}, with an origin of \code{1970-01-15}, the only pieces of information
that are used are the year and the month, and not the fact that the origin
starts on the 15th of the month. The exceptions to this are \code{"week"} and
\code{"quarter"}, see below.

For \code{by = "week"}, a week is defined as a 7 day period starting
from the \code{origin}'s year-month-day value.

For \code{by = "quarter"}, a quarter is defined as a 3 month period starting
from the \code{origin}'s year-month value.
}
\examples{
x <- as.Date("1970-01-01") + -4:4
x

# Compute monthly distances (really, year + month)
warp_distance(x, "month")

# Compute distances every 2 days, relative to "1970-01-01"
warp_distance(x, "day", every = 2)

# Compute distances every 2 days, this time relative to "1970-01-02"
warp_distance(x, "day", every = 2, origin = as.Date("1970-01-02"))

y <- as.POSIXct("1970-01-01 00:00:01", "UTC") + c(0, 2, 3, 4, 5, 6, 10)

# Compute distances every 5 seconds, starting from the unix epoch of
# 1970-01-01 00:00:00
# So this buckets:
# [1970-01-01 00:00:00, 1970-01-01 00:00:05) = 0
# [1970-01-01 00:00:05, 1970-01-01 00:00:10) = 1
# [1970-01-01 00:00:10, 1970-01-01 00:00:15) = 2
warp_distance(y, "second", every = 5)

# Compute distances every 5 seconds, starting from the minimum of `x`
# 1970-01-01 00:00:01
# So this buckets:
# [1970-01-01 00:00:01, 1970-01-01 00:00:06) = 0
# [1970-01-01 00:00:06, 1970-01-01 00:00:11) = 1
# [1970-01-01 00:00:11, 1970-01-01 00:00:16) = 2
origin <- as.POSIXct("1970-01-01 00:00:01", "UTC")
warp_distance(y, "second", every = 5, origin = origin)

# Differing time zones between `x` and `origin` can be particularly
# problematic. For this reason, if the time zones are different a warning
# is issued and `x` is coerced to the time zone of `origin`. The default
# `origin` time zone for the epoch is UTC.
x_in_nyc <- as.POSIXct("1970-01-01 01:00:00", "America/New_York")

# The default origin is `1970-01-01 00:00:00 UTC`.
# We passed in a clock time 1 hour after that, but in a different time zone.
# America/New_York is 5 hours behind UTC, so when it is converted to
# UTC the value becomes `1970-01-01 06:00:00 UTC`
warp_distance(x_in_nyc, "hour")

# We can use an origin value in our own time zone to fix this
# (it doesn't have to be 1970-01-01)
origin <- as.POSIXct("1970-01-01", "America/New_York")
warp_distance(x_in_nyc, "hour", origin = origin)

}
