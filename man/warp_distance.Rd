% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distance.R
\name{warp_distance}
\alias{warp_distance}
\title{Compute distances from a date time origin}
\usage{
warp_distance(x, by = "year", every = 1L, origin = NULL)
}
\arguments{
\item{x}{\verb{[Date / POSIXct / POSIXlt]}

A date time vector.}

\item{by}{\verb{[character(1)]}

A string defining the period to group by. Valid inputs are:
\itemize{
\item \code{"year"}
\item \code{"quarter"}
\item \code{"month"}
\item \code{"week"}
\item \code{"day"}
\item \code{"hour"}
\item \code{"minute"}
\item \code{"second"}
\item \code{"millisecond"}
}}

\item{every}{\verb{[positive integer(1)]}

The number of \code{by} periods to lump together when constructing the groups.
For example, with the default \code{origin} and \code{by = "year"}, \code{every = 2}
would put the years \code{1970} and \code{1971} in the same group.}

\item{origin}{\verb{[Date(1) / POSIXct(1) / POSIXlt(1)]}

The reference value for the distances to be computed from. This is
particularly important when \code{every > 1} and you need to define when the
"first" event was to start counting from.}
}
\value{
A double vector containing the distances.
}
\description{
\code{warp_distance()} is a low level engine for computing date time distances.

It returns the distance from \code{x} to the \code{origin} in units
defined by the period specified with \code{by}. For example, \code{by = "year"} would
return the number of years from the \code{origin}, which is the Unix epoch of
\verb{1970-01-01 00:00:00 UTC} by default.
}
\details{
The return value of \code{warp_distance()} is suitable for use as a grouping
column in, for example, a \code{dplyr::mutate()}. This is especially useful for
grouping by a multitude of a particular period, such as "every 5 months"
starting from your particular \code{origin} value. If you want "cleaner" grouping
values, you might consider running \code{vctrs::vec_group_id()} on the result from
\code{warp_distance()}.

When the time zone of \code{x} differs from the time zone of \code{origin}, a warning
is issued, and \code{x} is coerced to the time zone of \code{origin} without changing
the number of seconds of \code{x} from the epoch. In other words, the time zone
of \code{x} is directly changed to the time zone of \code{origin} without changing the
underlying numeric representation. \strong{It is highly advised to specify your own
\code{origin} value with the same time zone as \code{x}.}

If a \code{Date} is used for \code{x}, its time zone is assumed to be \code{"UTC"}.
}
\section{\code{origin} Truncation}{


For \code{by} values of \code{"year"} and \code{"month"}, the information provided in
\code{origin} is truncated. Practically this means that if you specify:\preformatted{warp_distance(by = "month", every = 2, origin = as.Date("1970-01-15"))
}

then only \code{1970-01} will be used, and not the fact that the origin starts
on the 15th of the month.

The \code{by} value of \code{"quarter"} is internally \verb{by = "month", every = every * 3}.
This means that for \code{"quarter"} the month specified for the \code{origin} will
be used as the month to start counting from to generate the 3 month quarter.

The \code{by} value of \code{"week"} is internally \verb{by = "day", every = every * 7}.
This means that for \code{"week"} the day of the month specified for the \code{origin}
will be used to start counting out the 7 day week. It can be useful to
set the origin to, say, a Monday to generate week groups that start on
Monday.

For by values of \code{"day"} and below with \code{POSIXct} objects, the internal
calculations are done on the number of seconds from the unix origin. For
\code{"day"} this means that you could use an \code{origin} value in the middle of
the day, and daily distances would be computed from that exact time point.
}

\section{Precision}{


With \code{POSIXct}, the limit of precision is approximately the microsecond
level. Only dates that are very close to the unix origin of 1970-01-01 can
possibly represent microsecond resolution correctly (close being within
about 40 years on either side). Otherwise, the values past the microsecond
resolution are essentially random, and can cause problems for the distance
calculations. Because of this, decimal digits past the microsecond range are
zeroed out, so please do not attempt to rely on them. It should still be safe
to work with microseconds, by, say, bucketing them by millisecond distances.
}

\examples{
x <- as.Date("1970-01-01") + -4:4
x

# Compute monthly distances (really, year + month)
warp_distance(x, "month")

# Compute distances every 2 days, relative to "1970-01-01"
warp_distance(x, "day", every = 2)

# Compute distances every 2 days, this time relative to "1970-01-02"
warp_distance(x, "day", every = 2, origin = as.Date("1970-01-02"))

y <- as.POSIXct("1970-01-01 00:00:01", "UTC") + c(0, 2, 3, 4, 5, 6, 10)

# Compute distances every 5 seconds, starting from the unix epoch of
# 1970-01-01 00:00:00
# So this buckets:
# [1970-01-01 00:00:00, 1970-01-01 00:00:05) = 0
# [1970-01-01 00:00:05, 1970-01-01 00:00:10) = 1
# [1970-01-01 00:00:10, 1970-01-01 00:00:15) = 2
warp_distance(y, "second", every = 5)

# Compute distances every 5 seconds, starting from the minimum of `x`
# 1970-01-01 00:00:01
# So this buckets:
# [1970-01-01 00:00:01, 1970-01-01 00:00:06) = 0
# [1970-01-01 00:00:06, 1970-01-01 00:00:11) = 1
# [1970-01-01 00:00:11, 1970-01-01 00:00:16) = 2
origin <- as.POSIXct("1970-01-01 00:00:01", "UTC")
warp_distance(y, "second", every = 5, origin = origin)

# Differing time zones between `x` and `origin` can be particularly
# problematic. For this reason, if the time zones are different a warning
# is issued and `x` is coerced to the time zone of `origin`. The default
# `origin` time zone for the epoch is UTC.
x_in_nyc <- as.POSIXct("1970-01-01 01:00:00", "America/New_York")

# The default origin is `1970-01-01 00:00:00 UTC`.
# We passed in a clock time 1 hour after that, but in a different time zone.
# America/New_York is 5 hours behind UTC, so when it is converted to
# UTC the value becomes `1970-01-01 06:00:00 UTC`
warp_distance(x_in_nyc, "hour")

# We can use an origin value in our own time zone to fix this
# (it doesn't have to be 1970-01-01)
origin <- as.POSIXct("1970-01-01", "America/New_York")
warp_distance(x_in_nyc, "hour", origin = origin)

}
