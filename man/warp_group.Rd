% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group.R
\name{warp_group}
\alias{warp_group}
\title{Group a date vector by period}
\usage{
warp_group(x, by = "year", every = 1L, origin = NULL)
}
\arguments{
\item{x}{\verb{[Date / POSIXct / POSIXlt]}

The vector to compute time groups for.}

\item{by}{\verb{[character(1)]}

A string defining the period to group by. Valid inputs are:
\itemize{
\item \code{"year"}
\item \code{"month"}
\item \code{"day"}
\item \code{"hour"}
\item \code{"minute"}
\item \code{"second"}
}}

\item{every}{\verb{[positive integer(1)]}

The number of \code{by} periods to lump together when constructing the groups.
For example, withe the default \code{origin} and \code{by = "year"}, \code{every = 2}
would put the years \code{1970} and \code{1971} in the same group.}

\item{origin}{\verb{[Date(1) / POSIXct(1) / POSIXlt(1)]}

The reference value for the groups to be computed from. This is
particularly important when \code{every > 1} and you need to define when the
"first" event was to start counting from.}
}
\description{
\code{warp_group()} is a low level engine for constructing groups by period for a
date vector. It returns the distance from \code{x} to the \code{origin} in units
defined by the period specified with \code{by}. For example, \code{by = "year"} would
return the number of years from the \code{origin}, which is the Unix epoch of
\verb{1970-01-01 00:00:00} by default.
}
\details{
The return value of \code{warp_group()} is suitable for use as a grouping column
in, for example, a \code{dplyr::mutate()}. This is especially useful for grouping
by a multitude of a particular period, such as "every 5 months" starting from
your particular \code{origin} value.

When the time zone of \code{x} differs from the time zone of \code{origin}, a warning
is issued, and \code{x} is coerced to the time zone of \code{origin} without changing
the number of seconds of \code{x} from the epoch. In other words, the time zone
of \code{x} is directly changed to the time zone of \code{origin} without changing the
underlying numeric representation. \strong{It is highly advised to specify your own
\code{origin} value with the same time zone as \code{x}.}

If a \code{Date} is used for \code{x}, its time zone is assumed to be \code{"UTC"}.

The information in the provided \code{origin} is truncated by the \code{by} period
specified. This means that if you specify \code{by = "month"},
\code{every = 2}, with an origin of \code{1970-01-15}, the only pieces of information
that are used are the year and the month, and not the fact that the origin
starts on the 15th of the month.
}
\examples{
x <- as.Date("1970-01-01") + -4:4
x

# Group by month (really, year + month)
warp_group(x, "month")

# Group by every 2 days, relative to "1970-01-01"
warp_group(x, "day", every = 2)

# Group by every 2 days, this time relative to "1970-01-02"
warp_group(x, "day", every = 2, origin = as.Date("1970-01-02"))

y <- as.POSIXct("1970-01-01 00:00:01", "UTC") + c(0, 2, 3, 4, 5, 6, 10)

# Group by every 5 seconds, starting from the unix epoch of
# 1970-01-01 00:00:00
# So this buckets:
# [1970-01-01 00:00:00, 1970-01-01 00:00:05) = 0
# [1970-01-01 00:00:05, 1970-01-01 00:00:10) = 1
# [1970-01-01 00:00:10, 1970-01-01 00:00:15) = 2
warp_group(y, "second", every = 5)

# Group by every 5 seconds, starting from the minimum of `x`
# 1970-01-01 00:00:01
# So this buckets:
# [1970-01-01 00:00:01, 1970-01-01 00:00:06) = 0
# [1970-01-01 00:00:06, 1970-01-01 00:00:11) = 1
# [1970-01-01 00:00:11, 1970-01-01 00:00:16) = 2
origin <- as.POSIXct("1970-01-01 00:00:01", "UTC")
warp_group(y, "second", every = 5, origin = origin)

}
