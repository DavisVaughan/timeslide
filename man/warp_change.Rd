% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/change.R
\name{warp_change}
\alias{warp_change}
\title{Detect changes in a date time vector}
\usage{
warp_change(x, by = "year", every = 1L, origin = NULL)
}
\arguments{
\item{x}{\verb{[Date / POSIXct / POSIXlt]}

A date time vector.}

\item{by}{\verb{[character(1)]}

A string defining the period to group by. Valid inputs are:
\itemize{
\item \code{"year"}
\item \code{"quarter"}
\item \code{"month"}
\item \code{"week"}
\item \code{"day"}
\item \code{"hour"}
\item \code{"minute"}
\item \code{"second"}
\item \code{"millisecond"}
}}

\item{every}{\verb{[positive integer(1)]}

The number of \code{by} periods to lump together when constructing the groups.
For example, with the default \code{origin} and \code{by = "year"}, \code{every = 2}
would put the years \code{1970} and \code{1971} in the same group.}

\item{origin}{\verb{[Date(1) / POSIXct(1) / POSIXlt(1)]}

The reference value for the distances to be computed from. This is
particularly important when \code{every > 1} and you need to define when the
"first" event was to start counting from.}
}
\value{
A double vector of locations right before a change.
}
\description{
\code{warp_change()} detects changes at the period level, using the period
supplied in \code{by}. It returns the locations of the last value before the
change. The location of the last value is always returned at the end.
}
\examples{
x <- as.Date("2019-01-01") + 0:5

warp_change(x, by = "day", every = 2)

warp_change(x, by = "day", every = 2, origin = as.Date("2019-01-01"))
}
