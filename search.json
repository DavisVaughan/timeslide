[{"path":[]},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@posit.co. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://davisvaughan.github.io/warp/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://davisvaughan.github.io/warp/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 warp authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://davisvaughan.github.io/warp/articles/hour.html","id":"spring-forward-gap","dir":"Articles","previous_headings":"","what":"Spring Forward Gap","title":"Hour Distances and Daylight Savings","text":"America/New_York’s time zone, time reach 1970-04-26 02:00:00, daylight savings kicked time shifts forward 1 hour next time actually 1970-04-26 03:00:00. warp_distance() treats hours 1 3 side side, since hour 2 ever existed. means hours (0, 1) (3, 4) get grouped together example. period = \"hour\" just computes running number 2 hour periods origin, pattern carries forward next day contiguous stream values. can somewhat confusing, since hours 0 1 don’t get grouped together 27th. One way can sort get around using lubridate’s force_tz() function force UTC time zone clock time original date. ’ve mocked poor man’s version function . UTC, hour 2 exists groups created (0, 1), (2, 3), , even though hour 2 doesn’t actually exist America/New_York DST gap. affect limiting (2, 3) group maximum size 1, since hour 3 possible data.","code":"before_dst <- as.POSIXct(\"1970-04-26 01:59:59\", tz = \"America/New_York\") before_dst #> [1] \"1970-04-26 01:59:59 EST\"  before_dst + 1 #> [1] \"1970-04-26 03:00:00 EDT\" x <- as.POSIXct(\"1970-04-26 00:00:00\", tz = \"America/New_York\") + 3600 * 0:7  data.frame(   x = x,   hour = warp_distance(x, \"hour\", every = 2) ) #>                     x hour #> 1 1970-04-26 00:00:00 1380 #> 2 1970-04-26 01:00:00 1380 #> 3 1970-04-26 03:00:00 1381 #> 4 1970-04-26 04:00:00 1381 #> 5 1970-04-26 05:00:00 1382 #> 6 1970-04-26 06:00:00 1382 #> 7 1970-04-26 07:00:00 1383 #> 8 1970-04-26 08:00:00 1383 y <- as.POSIXct(\"1970-04-26 22:00:00\", tz = \"America/New_York\") + 3600 * 0:5  data.frame(   y = y,   hour = warp_distance(y, \"hour\", every = 2) ) #>                     y hour #> 1 1970-04-26 22:00:00 1390 #> 2 1970-04-26 23:00:00 1391 #> 3 1970-04-27 00:00:00 1391 #> 4 1970-04-27 01:00:00 1392 #> 5 1970-04-27 02:00:00 1392 #> 6 1970-04-27 03:00:00 1393 # Or call `lubridate::force_tz(x, \"UTC\")` force_utc <- function(x) {   x_lt <- as.POSIXlt(x)   x_lt <- unclass(x_lt)      attributes(x) <- NULL      out <- x + x_lt$gmtoff      as.POSIXct(out, tz = \"UTC\", origin = \"1970-01-01\") }  x_utc <- force_utc(x) y_utc <- force_utc(y)  x_utc #> [1] \"1970-04-26 00:00:00 UTC\" \"1970-04-26 01:00:00 UTC\" #> [3] \"1970-04-26 03:00:00 UTC\" \"1970-04-26 04:00:00 UTC\" #> [5] \"1970-04-26 05:00:00 UTC\" \"1970-04-26 06:00:00 UTC\" #> [7] \"1970-04-26 07:00:00 UTC\" \"1970-04-26 08:00:00 UTC\" data.frame(   x_utc = x_utc,   hour = warp_distance(x_utc, \"hour\", every = 2) ) #>                 x_utc hour #> 1 1970-04-26 00:00:00 1380 #> 2 1970-04-26 01:00:00 1380 #> 3 1970-04-26 03:00:00 1381 #> 4 1970-04-26 04:00:00 1382 #> 5 1970-04-26 05:00:00 1382 #> 6 1970-04-26 06:00:00 1383 #> 7 1970-04-26 07:00:00 1383 #> 8 1970-04-26 08:00:00 1384  data.frame(   y_utc = y_utc,   hour = warp_distance(y_utc, \"hour\", every = 2) ) #>                 y_utc hour #> 1 1970-04-26 22:00:00 1391 #> 2 1970-04-26 23:00:00 1391 #> 3 1970-04-27 00:00:00 1392 #> 4 1970-04-27 01:00:00 1392 #> 5 1970-04-27 02:00:00 1393 #> 6 1970-04-27 03:00:00 1393"},{"path":"https://davisvaughan.github.io/warp/articles/hour.html","id":"fall-backwards-overlap","dir":"Articles","previous_headings":"","what":"Fall Backwards Overlap","title":"Hour Distances and Daylight Savings","text":"America/New_York’s time zone, time reach 1970-10-25 02:00:00, daylight savings kicked time shifts backwards 1 hour next time actually 1970-10-25 01:00:00. means 2 full hours hour value 1 day. two distinct hours, warp_distance() treats , example group (1 EDT, 1 EST) gets created. Since daylight savings currently active, also situation described hour 0 hour 1 grouped together. fallback adjustment actually realigns hours 0 1 next day, since 25th 25 hours. , one way sort avoid force UTC time zone. consequences two dates hour value 1. forced UTC, look identical. groups probably expect buckets hours (0, 1), (2, 3), , now two dates hour values 1 identical fall hour group.","code":"before_fallback <- as.POSIXct(\"1970-10-25 01:00:00\", tz = \"America/New_York\") before_fallback #> [1] \"1970-10-25 01:00:00 EDT\"  # add 1 hour of seconds before_fallback + 3600 #> [1] \"1970-10-25 01:00:00 EST\" x <- as.POSIXct(\"1970-10-25 00:00:00\", tz = \"America/New_York\") + 3600 * 0:7 x #> [1] \"1970-10-25 00:00:00 EDT\" \"1970-10-25 01:00:00 EDT\" #> [3] \"1970-10-25 01:00:00 EST\" \"1970-10-25 02:00:00 EST\" #> [5] \"1970-10-25 03:00:00 EST\" \"1970-10-25 04:00:00 EST\" #> [7] \"1970-10-25 05:00:00 EST\" \"1970-10-25 06:00:00 EST\"  data.frame(   x = x,   hour = warp_distance(x, \"hour\", every = 2) ) #>                     x hour #> 1 1970-10-25 00:00:00 3563 #> 2 1970-10-25 01:00:00 3564 #> 3 1970-10-25 01:00:00 3564 #> 4 1970-10-25 02:00:00 3565 #> 5 1970-10-25 03:00:00 3565 #> 6 1970-10-25 04:00:00 3566 #> 7 1970-10-25 05:00:00 3566 #> 8 1970-10-25 06:00:00 3567 y <- as.POSIXct(\"1970-10-25 22:00:00\", tz = \"America/New_York\") + 3600 * 0:5 y #> [1] \"1970-10-25 22:00:00 EST\" \"1970-10-25 23:00:00 EST\" #> [3] \"1970-10-26 00:00:00 EST\" \"1970-10-26 01:00:00 EST\" #> [5] \"1970-10-26 02:00:00 EST\" \"1970-10-26 03:00:00 EST\"  data.frame(   y = y,   hour = warp_distance(y, \"hour\", every = 2) ) #>                     y hour #> 1 1970-10-25 22:00:00 3575 #> 2 1970-10-25 23:00:00 3575 #> 3 1970-10-26 00:00:00 3576 #> 4 1970-10-26 01:00:00 3576 #> 5 1970-10-26 02:00:00 3577 #> 6 1970-10-26 03:00:00 3577 x_utc <- force_utc(x) x_utc #> [1] \"1970-10-25 00:00:00 UTC\" \"1970-10-25 01:00:00 UTC\" #> [3] \"1970-10-25 01:00:00 UTC\" \"1970-10-25 02:00:00 UTC\" #> [5] \"1970-10-25 03:00:00 UTC\" \"1970-10-25 04:00:00 UTC\" #> [7] \"1970-10-25 05:00:00 UTC\" \"1970-10-25 06:00:00 UTC\" data.frame(   x_utc = x_utc,   hour = warp_distance(x_utc, \"hour\", every = 2) ) #>                 x_utc hour #> 1 1970-10-25 00:00:00 3564 #> 2 1970-10-25 01:00:00 3564 #> 3 1970-10-25 01:00:00 3564 #> 4 1970-10-25 02:00:00 3565 #> 5 1970-10-25 03:00:00 3565 #> 6 1970-10-25 04:00:00 3566 #> 7 1970-10-25 05:00:00 3566 #> 8 1970-10-25 06:00:00 3567"},{"path":"https://davisvaughan.github.io/warp/articles/hour.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Hour Distances and Daylight Savings","text":"implementation period = \"hour\" technically correct, recognize isn’t intuitive operation. intuitive period value \"dhour\", correspond “hour day”. count number hour groups origin, like \"hour\" , reset every-hour counter every time enter new day. However, proved challenging code , hope incorporate eventually.","code":""},{"path":"https://davisvaughan.github.io/warp/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Davis Vaughan. Author, maintainer. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"https://davisvaughan.github.io/warp/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vaughan D (2023). warp: Group Dates. R package version 0.2.1,  https://davisvaughan.github.io/warp/, https://github.com/DavisVaughan/warp.","code":"@Manual{,   title = {warp: Group Dates},   author = {Davis Vaughan},   year = {2023},   note = {R package version 0.2.1,  https://davisvaughan.github.io/warp/},   url = {https://github.com/DavisVaughan/warp}, }"},{"path":"https://davisvaughan.github.io/warp/index.html","id":"warp","dir":"","previous_headings":"","what":"Group Dates","title":"Group Dates","text":"goal warp provide tooling group dates variety periods, : yearly, monthly, second, week month, .","code":"library(warp)"},{"path":"https://davisvaughan.github.io/warp/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Group Dates","text":"can install release version CRAN : can install development version GitHub :","code":"install.package(\"warp\") # install.packages(\"pak\") pak::pak(\"DavisVaughan/warp\")"},{"path":"https://davisvaughan.github.io/warp/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Group Dates","text":"One core functions warp warp_distance(), allows provide date time vector compute “distance” origin. example, computes number months unix epoch. values warp_distance() returns correspond distance x origin, units defined period width defined every. origin defaults unix epoch 1970-01-01 00:00:00 time zone x, can change . case distances saying , example, \"1970-01-02\" month origin, \"1969-12-31\" 1 month group away. can also compute daily distances. Rather grouping 1 day, let’s lump every 2 days together, starting default origin. often want set origin date. Let’s shift forward 1 1970-01-02. Another interesting period group \"mweek\", .e. week month. Notice days 1-7 January 1970 grouped bucket. Also note days 29-31 December 1969 fell end corresponding month. irregular week size 3 treated 5th week month, offset value -1 still number week buckets origin 1970-01-01.","code":"x <- as.Date(\"1970-01-01\") + -2:2 x #> [1] \"1969-12-30\" \"1969-12-31\" \"1970-01-01\" \"1970-01-02\" \"1970-01-03\"  warp_distance(x, period = \"month\") #> [1] -1 -1  0  0  0 # Groups 1970-01-01 and 1970-01-02 together warp_distance(x, period = \"day\", every = 2) #> [1] -1 -1  0  0  1 origin <- as.Date(\"1970-01-02\") origin #> [1] \"1970-01-02\"  # Groups 1970-01-02 and 1970-01-03 together warp_distance(x, period = \"day\", every = 2, origin = origin) #> [1] -2 -1 -1  0  0 y <- as.Date(\"1969-12-28\") + 0:14  tibble::tibble(   y = y,   mweek = warp_distance(y, \"mweek\") ) #> # A tibble: 15 × 2 #>    y          mweek #>    <date>     <dbl> #>  1 1969-12-28    -2 #>  2 1969-12-29    -1 #>  3 1969-12-30    -1 #>  4 1969-12-31    -1 #>  5 1970-01-01     0 #>  6 1970-01-02     0 #>  7 1970-01-03     0 #>  8 1970-01-04     0 #>  9 1970-01-05     0 #> 10 1970-01-06     0 #> 11 1970-01-07     0 #> 12 1970-01-08     1 #> 13 1970-01-09     1 #> 14 1970-01-10     1 #> 15 1970-01-11     1"},{"path":"https://davisvaughan.github.io/warp/index.html","id":"inspiration","dir":"","previous_headings":"","what":"Inspiration","title":"Group Dates","text":"algorithm warp_distance() inspired xts::endpoints().","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp-package.html","id":null,"dir":"Reference","previous_headings":"","what":"warp: Group Dates — warp-package","title":"warp: Group Dates — warp-package","text":"Tooling group dates variety periods including: yearly, monthly, second, week month, . groups defined way also represent distance dates terms period. extracts valuable information can used calculations rely specific temporal spacing observations.","code":""},{"path":[]},{"path":"https://davisvaughan.github.io/warp/reference/warp-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"warp: Group Dates — warp-package","text":"Maintainer: Davis Vaughan davis@posit.co contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_boundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate period boundaries for a date vector — warp_boundary","title":"Locate period boundaries for a date vector — warp_boundary","text":"warp_boundary() detects change time period along x, example, rolling one month next. returns start stop positions contiguous period chunk x.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_boundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate period boundaries for a date vector — warp_boundary","text":"","code":"warp_boundary(x, period, ..., every = 1L, origin = NULL)"},{"path":"https://davisvaughan.github.io/warp/reference/warp_boundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate period boundaries for a date vector — warp_boundary","text":"x [Date / POSIXct / POSIXlt] date time vector. period [character(1)] string defining period group . Valid inputs can roughly broken : \"year\", \"quarter\", \"month\", \"week\", \"day\" \"hour\", \"minute\", \"second\", \"millisecond\" \"yweek\", \"mweek\" \"yday\", \"mday\" ... [dots] dots future extensions must empty. every [positive integer(1)] number periods group together. example, period set \"year\" every value 2, years 1970 1971 placed group. origin [Date(1) / POSIXct(1) / POSIXlt(1) / NULL] reference date time value. default left NULL epoch time 1970-01-01 00:00:00, time zone index. generally used define anchor time count , relevant every value > 1.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_boundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate period boundaries for a date vector — warp_boundary","text":"two column data frame columns start stop. double vectors representing boundaries date time groups.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_boundary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Locate period boundaries for a date vector — warp_boundary","text":"stop positions just warp_change() values, start positions computed .","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_boundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate period boundaries for a date vector — warp_boundary","text":"","code":"x <- as.Date(\"1970-01-01\") + -4:5 x #>  [1] \"1969-12-28\" \"1969-12-29\" \"1969-12-30\" \"1969-12-31\" \"1970-01-01\" #>  [6] \"1970-01-02\" \"1970-01-03\" \"1970-01-04\" \"1970-01-05\" \"1970-01-06\"  # Boundaries by month warp_boundary(x, \"month\") #>   start stop #> 1     1    4 #> 2     5   10  # Bound by every 5 days, relative to \"1970-01-01\" # Creates boundaries of: # [1969-12-27, 1970-01-01) # [1970-01-01, 1970-01-06) # [1970-01-06, 1970-01-11) warp_boundary(x, \"day\", every = 5) #>   start stop #> 1     1    4 #> 2     5    9 #> 3    10   10  # Bound by every 5 days, relative to the smallest value in our vector origin <- min(x) origin #> [1] \"1969-12-28\"  # Creates boundaries of: # [1969-12-28, 1970-01-02) # [1970-01-02, 1970-01-07) warp_boundary(x, \"day\", every = 5, origin = origin) #>   start stop #> 1     1    5 #> 2     6   10"},{"path":"https://davisvaughan.github.io/warp/reference/warp_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect changes in a date time vector — warp_change","title":"Detect changes in a date time vector — warp_change","text":"warp_change() detects changes period level. last = TRUE, returns locations last value change, last location x always included. Additionally, endpoint = TRUE, first location x included. last = FALSE, returns locations first value change, first location x always included. Additionally, endpoint = TRUE, last location x included.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect changes in a date time vector — warp_change","text":"","code":"warp_change(   x,   period,   ...,   every = 1L,   origin = NULL,   last = TRUE,   endpoint = FALSE )"},{"path":"https://davisvaughan.github.io/warp/reference/warp_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect changes in a date time vector — warp_change","text":"x [Date / POSIXct / POSIXlt] date time vector. period [character(1)] string defining period group . Valid inputs can roughly broken : \"year\", \"quarter\", \"month\", \"week\", \"day\" \"hour\", \"minute\", \"second\", \"millisecond\" \"yweek\", \"mweek\" \"yday\", \"mday\" ... [dots] dots future extensions must empty. every [positive integer(1)] number periods group together. example, period set \"year\" every value 2, years 1970 1971 placed group. origin [Date(1) / POSIXct(1) / POSIXlt(1) / NULL] reference date time value. default left NULL epoch time 1970-01-01 00:00:00, time zone index. generally used define anchor time count , relevant every value > 1. last [logical(1)] TRUE, last location change returned. last location input always returned. FALSE, first location change returned. first location input always returned. endpoint [logical(1)] TRUE last = TRUE, additionally return first location input. TRUE last = FALSE, additionally return last location input. FALSE, nothing.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_change.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect changes in a date time vector — warp_change","text":"double vector locations.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect changes in a date time vector — warp_change","text":"","code":"x <- as.Date(\"2019-01-01\") + 0:5 x #> [1] \"2019-01-01\" \"2019-01-02\" \"2019-01-03\" \"2019-01-04\" \"2019-01-05\" #> [6] \"2019-01-06\"  # Last location before a change, last location of `x` is always included warp_change(x, period = \"yday\", every = 2, last = TRUE) #> [1] 2 4 6  # Also include first location warp_change(x, period = \"yday\", every = 2, last = TRUE, endpoint = TRUE) #> [1] 1 2 4 6  # First location after a change, first location of `x` is always included warp_change(x, period = \"yday\", every = 2, last = FALSE) #> [1] 1 3 5  # Also include last location warp_change(x, period = \"yday\", every = 2, last = FALSE, endpoint = TRUE) #> [1] 1 3 5 6"},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute distances from a date time origin — warp_distance","title":"Compute distances from a date time origin — warp_distance","text":"warp_distance() low level engine computing date time distances. returns distance x origin units defined period. example, period = \"year\" return number years origin. Setting every = 2 return number 2 year groups origin.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute distances from a date time origin — warp_distance","text":"","code":"warp_distance(x, period, ..., every = 1L, origin = NULL)"},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute distances from a date time origin — warp_distance","text":"x [Date / POSIXct / POSIXlt] date time vector. period [character(1)] string defining period group . Valid inputs can roughly broken : \"year\", \"quarter\", \"month\", \"week\", \"day\" \"hour\", \"minute\", \"second\", \"millisecond\" \"yweek\", \"mweek\" \"yday\", \"mday\" ... [dots] dots future extensions must empty. every [positive integer(1)] number periods group together. example, period set \"year\" every value 2, years 1970 1971 placed group. origin [Date(1) / POSIXct(1) / POSIXlt(1) / NULL] reference date time value. default left NULL epoch time 1970-01-01 00:00:00, time zone index. generally used define anchor time count , relevant every value > 1.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute distances from a date time origin — warp_distance","text":"double vector containing distances.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute distances from a date time origin — warp_distance","text":"return value warp_distance() variety uses. can used : grouping column dplyr::group_by(). especially useful grouping multitude particular period, \"every 5 months\". Computing distances values x, units period. returning distances origin, warp_distance() also implicitly computed distances values x. used slide::block() break input time blocks. time zone x differs time zone origin, warning issued, x coerced time zone origin without changing number seconds x epoch. words, time zone x directly changed time zone origin without changing underlying numeric representation. highly advised specify origin value time zone x. Date used x, time zone assumed \"UTC\".","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":"period","dir":"Reference","previous_headings":"","what":"Period","title":"Compute distances from a date time origin — warp_distance","text":"period values \"year\", \"month\", \"day\", information provided origin truncated. Practically means specify:   1970-01 used, fact origin starts 15th month. period value \"quarter\" internally period = \"month\", every = every * 3. means \"quarter\" month specified origin used month start counting generate 3 month quarter. mimic behavior lubridate::floor_date(), use period = \"week\". Internally just period = \"day\", every = every * 7. mimic week_start argument floor_date(), set origin date week day identical one want week start . example, default origin 1970-01-01 Thursday, generate groups identical floor_date(week_start = 4). period value \"yday\" computed complete every-day periods origin, forced reset every-day counter every time hit month-day value origin. \"yweek\" built top internally period = \"yday\", every = every * 7. ends using algorithm similar lubridate::week(), added benefit able control origin date. period value \"mday\" computed every-day periods within month, forced reset every-day counter first day month. useful application \"mweek\", implemented period = \"mday\", every = every * 7. allows group \"week month\". \"mday\" \"mweek\", year month parts origin value used. , origin argument interesting periods. \"hour\" period (granular frequencies) can produce results might surprising, even technically correct. See vignette vignette(\"hour\", package = \"warp\") information.","code":"warp_distance(period = \"month\", origin = as.Date(\"1970-01-15\"))"},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":"precision","dir":"Reference","previous_headings":"","what":"Precision","title":"Compute distances from a date time origin — warp_distance","text":"POSIXct, limit precision approximately microsecond level. dates close unix origin 1970-01-01 can possibly represent microsecond resolution correctly (close within 40 years either side). Otherwise, values past microsecond resolution essentially random, can cause problems distance calculations. , decimal digits past microsecond range zeroed , please attempt rely . still safe work microseconds, , say, bucketing millisecond distances.","code":""},{"path":"https://davisvaughan.github.io/warp/reference/warp_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute distances from a date time origin — warp_distance","text":"","code":"x <- as.Date(\"1970-01-01\") + -4:4 x #> [1] \"1969-12-28\" \"1969-12-29\" \"1969-12-30\" \"1969-12-31\" \"1970-01-01\" #> [6] \"1970-01-02\" \"1970-01-03\" \"1970-01-04\" \"1970-01-05\"  # Compute monthly distances (really, year + month) warp_distance(x, \"month\") #> [1] -1 -1 -1 -1  0  0  0  0  0  # Compute distances every 2 days, relative to \"1970-01-01\" warp_distance(x, \"day\", every = 2) #> [1] -2 -2 -1 -1  0  0  1  1  2  # Compute distances every 2 days, this time relative to \"1970-01-02\" warp_distance(x, \"day\", every = 2, origin = as.Date(\"1970-01-02\")) #> [1] -3 -2 -2 -1 -1  0  0  1  1  y <- as.POSIXct(\"1970-01-01 00:00:01\", \"UTC\") + c(0, 2, 3, 4, 5, 6, 10)  # Compute distances every 5 seconds, starting from the unix epoch of # 1970-01-01 00:00:00 # So this buckets: # [1970-01-01 00:00:00, 1970-01-01 00:00:05) = 0 # [1970-01-01 00:00:05, 1970-01-01 00:00:10) = 1 # [1970-01-01 00:00:10, 1970-01-01 00:00:15) = 2 warp_distance(y, \"second\", every = 5) #> [1] 0 0 0 1 1 1 2  # Compute distances every 5 seconds, starting from the minimum of `x` # 1970-01-01 00:00:01 # So this buckets: # [1970-01-01 00:00:01, 1970-01-01 00:00:06) = 0 # [1970-01-01 00:00:06, 1970-01-01 00:00:11) = 1 # [1970-01-01 00:00:11, 1970-01-01 00:00:16) = 2 origin <- as.POSIXct(\"1970-01-01 00:00:01\", \"UTC\") warp_distance(y, \"second\", every = 5, origin = origin) #> [1] 0 0 0 0 1 1 2  # --------------------------------------------------------------------------- # Time zones  # When `x` is not UTC and `origin` is left as `NULL`, the origin is set as # 1970-01-01 00:00:00 in the time zone of `x`. This seems to be the most # practically useful default. z <- as.POSIXct(\"1969-12-31 23:00:00\", \"UTC\") z_in_nyc <- as.POSIXct(\"1969-12-31 23:00:00\", \"America/New_York\")  # Practically this means that these give the same result, because their # `origin` values are defined in their respective time zones. warp_distance(z, \"year\") #> [1] -1 warp_distance(z_in_nyc, \"year\") #> [1] -1  # Compare that to what would happen if we used a static `origin` of # 1970-01-01 00:00:00 UTC. # America/New_York is 5 hours behind UTC, so when `z_in_nyc` is converted to # UTC the value becomes `1970-01-01 04:00:00 UTC`, a different year. Because # this is generally surprising, a warning is thrown. origin <- as.POSIXct(\"1970-01-01 00:00:00\", tz = \"UTC\") warp_distance(z, \"year\", origin = origin) #> [1] -1 warp_distance(z_in_nyc, \"year\", origin = origin) #> Warning: `x` (America/New_York) and `origin` (UTC) do not have the same time zone. Converting `x` to the time zone of `origin`. It is highly advised to provide `x` and `origin` with the same time zone. #> [1] 0  # --------------------------------------------------------------------------- # `period = \"yweek\"`  x <- as.Date(\"2019-12-23\") + 0:16 origin <- as.Date(\"1970-01-01\")  # `\"week\"` counts the number of 7 day periods from the `origin` # `\"yweek\"` restarts the 7 day counter every time you hit the month-day # value of the `origin`. Notice how, for the `yweek` column, only 1 day was # in the week starting with `2019-12-31`. This is because the next day is # `2020-01-01`, which aligns with the month-day value of the `origin`. data.frame(   x = x,   week = warp_distance(x, \"week\", origin = origin),   yweek = warp_distance(x, \"yweek\", origin = origin) ) #>             x week yweek #> 1  2019-12-23 2607  2647 #> 2  2019-12-24 2607  2648 #> 3  2019-12-25 2607  2648 #> 4  2019-12-26 2608  2648 #> 5  2019-12-27 2608  2648 #> 6  2019-12-28 2608  2648 #> 7  2019-12-29 2608  2648 #> 8  2019-12-30 2608  2648 #> 9  2019-12-31 2608  2649 #> 10 2020-01-01 2608  2650 #> 11 2020-01-02 2609  2650 #> 12 2020-01-03 2609  2650 #> 13 2020-01-04 2609  2650 #> 14 2020-01-05 2609  2650 #> 15 2020-01-06 2609  2650 #> 16 2020-01-07 2609  2650 #> 17 2020-01-08 2609  2651  # --------------------------------------------------------------------------- # `period = \"mweek\"`  x <- as.Date(\"2019-12-23\") + 0:16  # `\"mweek\"` breaks `x` up into weeks of the month. Notice how days 1-7 # of 2020-01 all have the same distance value. A forced reset of the 7 day # counter is done at the 1st of every month. This results in the 3 day # week of the month at the end of 2019-12, from 29-31. data.frame(   x = x,   mweek = warp_distance(x, \"mweek\") ) #>             x mweek #> 1  2019-12-23  2960 #> 2  2019-12-24  2960 #> 3  2019-12-25  2960 #> 4  2019-12-26  2960 #> 5  2019-12-27  2960 #> 6  2019-12-28  2960 #> 7  2019-12-29  2961 #> 8  2019-12-30  2961 #> 9  2019-12-31  2961 #> 10 2020-01-01  2962 #> 11 2020-01-02  2962 #> 12 2020-01-03  2962 #> 13 2020-01-04  2962 #> 14 2020-01-05  2962 #> 15 2020-01-06  2962 #> 16 2020-01-07  2962 #> 17 2020-01-08  2963"},{"path":"https://davisvaughan.github.io/warp/news/index.html","id":"warp-021","dir":"Changelog","previous_headings":"","what":"warp 0.2.1","title":"warp 0.2.1","text":"Fixed test related R-devel bugfix .POSIXlt() (#36).","code":""},{"path":"https://davisvaughan.github.io/warp/news/index.html","id":"warp-020","dir":"Changelog","previous_headings":"","what":"warp 0.2.0","title":"warp 0.2.0","text":"CRAN release: 2020-10-21 optional arguments must now specified name. warp_change() two new arguments, last endpoint, controlling exactly type change points returned.","code":""},{"path":"https://davisvaughan.github.io/warp/news/index.html","id":"warp-010","dir":"Changelog","previous_headings":"","what":"warp 0.1.0","title":"warp 0.1.0","text":"CRAN release: 2020-01-14 Added NEWS.md file track changes package.","code":""}]
